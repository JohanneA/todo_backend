package com.hexagonkt.todokt.backend

import com.hexagonkt.helpers.CodedException
import com.hexagonkt.http.get
import com.hexagonkt.http.server.Call
import com.hexagonkt.http.server.Server
import com.hexagonkt.http.server.jetty.JettyServletAdapter
import com.hexagonkt.serialization.Json
import com.hexagonkt.settings.SettingsManager.requireSetting
import com.hexagonkt.store.mongodb.MongoDbStore
import com.hexagonkt.templates.pebble.PebbleAdapter
import com.hexagonkt.web.template
import java.time.LocalDateTime
import java.util.*
import kotlin.text.Charsets.UTF_8

/**
 * Task entity.
 *
 * Todo: Update this to follow the spec. Have url, title, completed, order
 */
data class Task(
    val id: String,
    val title: String,
    val order: Int? = null,
    val createdAt: LocalDateTime = LocalDateTime.now(),
    val completedAt: LocalDateTime? = null
)

/** Store for tasks. */
val store = MongoDbStore(Task::class, Task::id, requireSetting("mongoDbUrl") as String)

fun main(vararg args: String) {
    val server = Server(JettyServletAdapter()) {
        // Serves 'resources/public' classpath folder from servers root '/'
        get("/public")

        // Renders index page from Pebble template. SPA which code is generated by Frontend module
        get {
            template(PebbleAdapter, "index.html")
        }

        path("/tasks") {
            cors()

            get {
                val tasks = store.findAll()

                val taskResponse = TasksRetrievalResponse(
                    tasks.map{
                        TaskRetrievalResponse(
                            url         = it.id,
                            title       = it.title,
                            order       = it.order,
                            completed   = it.completedAt?.isBefore(LocalDateTime.now())
                        )
                    }
                )

                ok(taskResponse, Json, UTF_8)
            }

            get("/{id}") {
                val id = request.pathParameters["id"]

                getTask(id)

            }

            post {
                val taskCreationRequest = request.body<TaskCreationRequestRoot>().task
                val task = Task(
                    id       = generateId(),
                    title    = taskCreationRequest.title
                )

                store.saveOne(task)

                getTask(task.id)
            }

            patch("/{id}") {
                val id = request.pathParameters["id"]
                val taskUpdateRequest = request.body<TaskUpdateRequestRoot>().task

                val task = store.findOne(id) ?: halt(404, "Task with id $id not found")

                val updates = mapOf(
                    TaskUpdateRequest::title.name to taskUpdateRequest.title,
                    TaskUpdateRequest::order.name to taskUpdateRequest.order,
                    TaskUpdateRequest::completed.name to taskUpdateRequest.completed?.let {
                        if(it && task.completedAt == null) LocalDateTime.now()
                        else task.completedAt
                    }
                )

                if (store.updateOne(id, updates)) getTask(id)
                else halt(400, "Unable to update task with id $id")
            }


            delete {
                store.drop()
            }
        }


        setOf(401, 403, 404, 500).forEach { code ->
            error(code) { statusCodeHandler(it) }
        }
    }

    server.start()
}

internal fun generateId(): String {
    return UUID.randomUUID().toString()
}

internal fun Call.getTask(id: String) {
    val task = store.findOne(id) ?: halt(404, "Task with id $id not found")

    val taskResponse = TaskRetrievalResponseRoot(
        TaskRetrievalResponse(
            url         = task.id,
            title       = task.title,
            order       = task.order,
            completed   = task.completedAt?.isBefore(LocalDateTime.now())
        )
    )

    ok(taskResponse, Json, UTF_8)
}

internal fun Call.statusCodeHandler(exception: CodedException) {
    @Suppress("MoveVariableDeclarationIntoWhen") // Required because response.body is an expression
    val body = response.body

    val messages = when (body) {
        is List<*> -> body.mapNotNull { it?.toString() }
        else -> listOf(exception.message ?: exception::class.java.name)
    }

    send(exception.code, ErrorResponse(messages), Json, UTF_8)
}
